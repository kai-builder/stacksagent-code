id,language,category,name,description,code,imports_or_contract,notes
1,javascript,create,txid-chainhook,"Create chainhook for specific transaction","const chainhookTemplate = { name: 'my-chainhook', uuid: uuidv4(), chain: 'stacks', version: 1, networks: { mainnet: { if_this: { scope: 'txid', equals: txId }, then_that: { http_post: { url: 'https://myapp.com/api/hook', authorization_header: `Bearer ${SECRET}` } }, start_block: startBlock, decode_clarity_values: true } } }; await fetch(`https://api.platform.hiro.so/v1/ext/${API_KEY}/chainhooks`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(chainhookTemplate) })","import { v4 as uuidv4 } from 'uuid'","Transaction-based hook; fires when specific tx_id is confirmed; good for order tracking"
2,javascript,create,contract-call-chainhook,"Create chainhook for contract function calls","const chainhookTemplate = { name: 'swap-monitor', uuid: uuidv4(), chain: 'stacks', version: 1, networks: { mainnet: { if_this: { scope: 'contract_call', contract_identifier: 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.alex-vault', method: 'swap-helper' }, then_that: { http_post: { url: hookUrl, authorization_header: `Bearer ${SECRET}` } }, start_block: currentBlock } } }","import { v4 as uuidv4 } from 'uuid'","Monitor specific contract function; fires on every call to method; use for DEX swaps tracking"
3,javascript,create,print-event-chainhook,"Create chainhook for Clarity print events","const chainhookTemplate = { name: 'event-listener', uuid: uuidv4(), chain: 'stacks', version: 1, networks: { mainnet: { if_this: { scope: 'print_event', contract_identifier: 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.nft-marketplace', contains: 'sale-complete' }, then_that: { http_post: { url: hookUrl, authorization_header: `Bearer ${SECRET}` } }, start_block: startBlock } } }","import { v4 as uuidv4 } from 'uuid'","Listen for Clarity print statements; useful for custom events; 'contains' filters by event name"
4,javascript,create,ft-event-chainhook,"Create chainhook for fungible token events","const chainhookTemplate = { name: 'token-monitor', uuid: uuidv4(), chain: 'stacks', version: 1, networks: { mainnet: { if_this: { scope: 'ft_event', asset_identifier: 'SP3K8BC0PPEVCV7NZ6QSRWPQ2JE9E5B6N3PA0KBR9.token-abtc::abtc', actions: ['mint', 'transfer', 'burn'] }, then_that: { http_post: { url: hookUrl, authorization_header: `Bearer ${SECRET}` } }, start_block: currentBlock } } }","import { v4 as uuidv4 } from 'uuid'","Track FT events (mint/transfer/burn); monitors specific token contract; good for token analytics"
5,javascript,create,nft-event-chainhook,"Create chainhook for NFT events","const chainhookTemplate = { name: 'nft-tracker', uuid: uuidv4(), chain: 'stacks', version: 1, networks: { mainnet: { if_this: { scope: 'nft_event', asset_identifier: 'SP2X0TZ59D5SZ8ACQ6YMCHHNR2ZN51Z32E2CJ173.bitcoin-monkeys::bitcoin-monkeys', actions: ['mint', 'transfer', 'burn'] }, then_that: { http_post: { url: hookUrl, authorization_header: `Bearer ${SECRET}` } }, start_block: currentBlock } } }","import { v4 as uuidv4 } from 'uuid'","Monitor NFT collection events; tracks mints and transfers; useful for marketplace indexing"
6,javascript,create,stx-event-chainhook,"Create chainhook for STX transfer events","const chainhookTemplate = { name: 'stx-transfers', uuid: uuidv4(), chain: 'stacks', version: 1, networks: { mainnet: { if_this: { scope: 'stx_event', actions: ['transfer', 'mint', 'lock'] }, then_that: { http_post: { url: hookUrl, authorization_header: `Bearer ${SECRET}` } }, start_block: currentBlock } } }","import { v4 as uuidv4 } from 'uuid'","Track all STX transfers; monitor stacking locks; use sparingly (high volume)"
7,javascript,webhook,chainhook-handler,"Handle chainhook webhook POST","export async function POST(req: NextRequest) { const authHeader = req.headers.get('authorization'); if (authHeader !== `Bearer ${CHAINHOOK_BEARER}`) { return new NextResponse('Unauthorized', { status: 401 }); } const body = await req.json(); const txId = body.chainhook.predicate.equals; const chainhookUuid = body.chainhook.uuid; // Process transaction... return new NextResponse(JSON.stringify({ success: true }), { status: 200 }) }","import { NextRequest, NextResponse } from 'next/server'","Webhook handler pattern; verify bearer token; extract tx_id from payload; always return 200"
8,javascript,webhook,verify-tx-status,"Verify transaction status in webhook","const txId = body.chainhook.predicate.equals; const txResponse = await fetch(`https://api.mainnet.hiro.so/extended/v1/tx/${txId}`); const txData = await txResponse.json(); if (txData.tx_status === 'success') { // Update database... console.log('Transaction confirmed') }","fetch","Fetch full tx details; check tx_status; handle success vs failed vs pending"
9,javascript,webhook,delete-chainhook,"Delete chainhook after processing","const chainhookUuid = body.chainhook.uuid; const deleteResponse = await fetch(`https://api.platform.hiro.so/v1/ext/${CHAINHOOK_API}/chainhooks/${chainhookUuid}`, { method: 'DELETE', headers: { 'Content-Type': 'application/json' } }); if (deleteResponse.ok) { console.log('Chainhook deleted') }","fetch","Clean up one-time hooks; prevents duplicate webhook calls; good for order confirmations"
10,javascript,webhook,parse-contract-source,"Parse smart contract source code","const contractId = txData.smart_contract?.contract_id; const sourceCode = txData.smart_contract?.source_code; const stxTransferPattern = /\(try!\s*\(stx-transfer\?\s+u(\d+)\s+tx-sender\s+'([^']+)\)\)/g; const matches = [...sourceCode.matchAll(stxTransferPattern)]; matches.forEach(match => { const amount = parseInt(match[1]); const recipient = match[2]; console.log(`Transfer: ${amount} to ${recipient}`) })","None","Extract data from deployed contracts; parse Clarity code with regex; useful for airdrop analysis"
11,javascript,webhook,send-notification,"Send Telegram notification from webhook","const message = `New transaction confirmed: ${txId}`; await fetch(`https://api.telegram.org/bot${TELEGRAM_API}/sendMessage`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ chat_id: CHAT_ID, text: message, parse_mode: 'HTML' }) })","fetch","Push notifications on blockchain events; use Telegram, Discord, etc; HTML formatting supported"
12,javascript,management,list-chainhooks,"List all active chainhooks","const response = await fetch(`https://api.platform.hiro.so/v1/ext/${CHAINHOOK_API}/chainhooks`, { method: 'GET', headers: { 'Content-Type': 'application/json' } }); const chainhooks = await response.json(); console.log('Active chainhooks:', chainhooks.length)","fetch","Retrieve all registered hooks; check status; useful for debugging"
13,javascript,management,get-chainhook,"Get specific chainhook details","const response = await fetch(`https://api.platform.hiro.so/v1/ext/${CHAINHOOK_API}/chainhooks/${uuid}`, { method: 'GET', headers: { 'Content-Type': 'application/json' } }); const chainhook = await response.json(); console.log('Chainhook:', chainhook.name)","fetch","Fetch single hook by UUID; check configuration; verify it's running"
14,javascript,management,update-chainhook,"Update existing chainhook","const updatedTemplate = { ...existingChainhook, networks: { mainnet: { ...existingChainhook.networks.mainnet, end_block: currentBlock + 1000 } } }; await fetch(`https://api.platform.hiro.so/v1/ext/${CHAINHOOK_API}/chainhooks/${uuid}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(updatedTemplate) })","fetch","Modify hook configuration; change end_block; update webhook URL"
15,javascript,management,delete-chainhook-by-uuid,"Delete chainhook by UUID","await fetch(`https://api.platform.hiro.so/v1/ext/${CHAINHOOK_API}/chainhooks/${uuid}`, { method: 'DELETE', headers: { 'Content-Type': 'application/json' } })","fetch","Manual cleanup; remove unused hooks; prevents webhook spam"
16,javascript,advanced,chainhook-with-end-block,"Create chainhook with expiration","const chainhookTemplate = { name: 'limited-hook', uuid: uuidv4(), chain: 'stacks', version: 1, networks: { mainnet: { if_this: { scope: 'txid', equals: txId }, then_that: { http_post: { url: hookUrl, authorization_header: `Bearer ${SECRET}` } }, start_block: startBlock, end_block: startBlock + 100, decode_clarity_values: true } } }","import { v4 as uuidv4 } from 'uuid'","Auto-expires after end_block; prevents orphaned hooks; good for time-limited campaigns"
17,javascript,advanced,chainhook-expire-after-occurrence,"Create one-time chainhook","const chainhookTemplate = { name: 'one-time-hook', uuid: uuidv4(), chain: 'stacks', version: 1, networks: { mainnet: { if_this: { scope: 'txid', equals: txId }, then_that: { http_post: { url: hookUrl, authorization_header: `Bearer ${SECRET}` } }, start_block: startBlock, expire_after_occurrence: 1 } } }","import { v4 as uuidv4 } from 'uuid'","Auto-deletes after first trigger; perfect for order confirmations; set to null for persistent hooks"
18,javascript,advanced,decode-clarity-values,"Enable Clarity value decoding","const chainhookTemplate = { ...baseTemplate, networks: { mainnet: { ...networkConfig, decode_clarity_values: true } } }","None","Decode Clarity responses; get human-readable values; recommended for all hooks"
19,javascript,patterns,ngrok-development,"Use ngrok for local development","let webhookUrl = 'https://myapp.com/api/hook'; if (process.env.NODE_ENV === 'development') { webhookUrl = 'https://abc123.ngrok-free.app/api/hook' }","None","Test webhooks locally; ngrok tunnels to localhost; remember to update for production"
20,javascript,patterns,bearer-auth,"Secure webhook with bearer token","const CHAINHOOK_BEARER = process.env.CHAINHOOK_SECRET; export async function POST(req: NextRequest) { const authHeader = req.headers.get('authorization'); if (authHeader !== `Bearer ${CHAINHOOK_BEARER}`) { return new NextResponse('Unauthorized', { status: 401 }) } // Process webhook... }","import { NextRequest, NextResponse } from 'next/server'","Always verify bearer token; prevents unauthorized access; use strong secrets"
21,javascript,patterns,handle-webhook-payload,"Extract data from webhook payload","const body = await req.json(); const txId = body.chainhook?.predicate?.equals; const chainhookUuid = body.chainhook?.uuid; const transactions = body.apply?.[0]?.metadata?.transactions || []; const txSuccess = transactions[0]?.metadata?.success; const sender = transactions[0]?.metadata?.sender","None","Webhook payload structure; apply[0] contains block data; check nested properties safely"
22,javascript,patterns,tx-format-0x,"Handle 0x transaction prefix","const txCorrectFormat = tx_id.startsWith('0x') ? tx_id : `0x${tx_id}`","None","Some APIs require 0x prefix; normalize tx_ids; prevents lookup failures"
23,javascript,patterns,database-update-on-confirm,"Update database on tx confirmation","if (txData.tx_status === 'success') { await db.update(orders).set({ status: 'confirmed', confirmed_at: new Date() }).where(eq(orders.tx_id, txId)) }","import { db } from '@/lib/db'; import { eq } from 'drizzle-orm'","Update order status; mark as confirmed; only on success status"
24,javascript,patterns,chainhook-naming,"Generate unique chainhook names","const chainhookName = `${eventType}-${contractName}-${txId.slice(-8)}`","None","Include event type + identifier + tx suffix; makes hooks identifiable; easier debugging"
25,javascript,bitcoin,bitcoin-chainhook,"Create Bitcoin chainhook","const chainhookTemplate = { name: 'btc-deposits', uuid: uuidv4(), chain: 'bitcoin', version: 1, networks: { mainnet: { if_this: { scope: 'outputs', descriptor: { type: 'p2pkh', address: 'bc1q...' } }, then_that: { http_post: { url: hookUrl, authorization_header: `Bearer ${SECRET}` } }, start_block: 800000 } } }","import { v4 as uuidv4 } from 'uuid'","Monitor Bitcoin addresses; track deposits; use descriptor for address patterns"
26,javascript,bitcoin,ordinals-chainhook,"Monitor Ordinals inscriptions","const chainhookTemplate = { name: 'ordinals-tracker', uuid: uuidv4(), chain: 'bitcoin', version: 1, networks: { mainnet: { if_this: { scope: 'ordinals_protocol', operation: 'inscription_feed' }, then_that: { http_post: { url: hookUrl, authorization_header: `Bearer ${SECRET}` } }, start_block: 767430 } } }","import { v4 as uuidv4 } from 'uuid'","Track Ordinals inscriptions; Bitcoin NFTs; start_block must be >= 767430 (Ordinals activation)"
27,javascript,patterns,multi-contract-monitoring,"Monitor multiple contracts","const contracts = ['SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.alex-vault', 'SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.velar-swap']; for (const contract of contracts) { const template = { ...baseTemplate, name: `swap-${contract.split('.')[1]}`, networks: { mainnet: { if_this: { scope: 'contract_call', contract_identifier: contract, method: 'swap' }, ...rest } } }; await createChainhook(template) }","None","Monitor multiple DEXs; create hooks in loop; track all swap activity"
28,javascript,patterns,historical-evaluation,"Test chainhook against past blocks","const chainhookTemplate = { ...baseTemplate, networks: { mainnet: { ...config, start_block: pastBlock, end_block: pastBlock + 100 } } }","None","Backfill historical data; test hook logic; useful for debugging predicates"
29,javascript,patterns,webhook-retry-logic,"Handle webhook delivery failures","export async function POST(req: NextRequest) { try { const body = await req.json(); await processWebhook(body); return new NextResponse(JSON.stringify({ success: true }), { status: 200 }) } catch (error) { console.error('Webhook processing failed:', error); return new NextResponse(JSON.stringify({ error: 'Processing failed' }), { status: 500 }) } }","import { NextRequest, NextResponse } from 'next/server'","Always return 200 on success; Chainhooks retries on non-200; idempotent handlers recommended"
30,javascript,patterns,idempotent-webhook,"Make webhook handler idempotent","const existingRecord = await db.query.orders.findFirst({ where: eq(orders.tx_id, txId) }); if (existingRecord?.status === 'confirmed') { console.log('Already processed'); return new NextResponse(JSON.stringify({ success: true }), { status: 200 }) } // Process webhook...","import { db } from '@/lib/db'; import { eq } from 'drizzle-orm'","Check if already processed; prevent duplicate actions; handle retries safely"
