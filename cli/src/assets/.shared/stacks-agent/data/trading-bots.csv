id,language,category,name,description,code,imports_or_contract,notes
1,javascript,wallet-sdk,restore-wallet-from-seed,"Restore wallet from seed phrase","import { generateWallet, generateNewAccount, restoreWalletAccounts, getStxAddress } from '@stacks/wallet-sdk'; import { StacksMainnet, TransactionVersion } from '@stacks/network'; const seedPhrase = process.env.SEED_PHASES; const password = process.env.PASSWORD; let restoredWallet = await generateWallet({ secretKey: seedPhrase, password: password ?? '' }); restoredWallet = generateNewAccount(restoredWallet); const wallet = await restoreWalletAccounts({ wallet: restoredWallet, gaiaHubUrl: 'https://hub.blockstack.org', network: new StacksMainnet() }); const mainnetAddr = getStxAddress({ account: restoredWallet.accounts[0], transactionVersion: TransactionVersion.Mainnet }); const account = wallet.accounts[0]","import { generateWallet, generateNewAccount, restoreWalletAccounts, getStxAddress } from '@stacks/wallet-sdk'; import { StacksMainnet, TransactionVersion } from '@stacks/network'","Use wallet-sdk for automated trading; stores seed in env; generates mainnet address; account.stxPrivateKey for signing"
2,javascript,wallet-sdk,get-wallet-addresses,"Get testnet and mainnet addresses","import { getStxAddress } from '@stacks/wallet-sdk'; import { TransactionVersion } from '@stacks/transactions'; const testnetAddr = getStxAddress({ account: wallet.accounts[0], transactionVersion: TransactionVersion.Testnet }); const mainnetAddr = getStxAddress({ account: wallet.accounts[0], transactionVersion: TransactionVersion.Mainnet })","import { getStxAddress } from '@stacks/wallet-sdk'; import { TransactionVersion } from '@stacks/transactions'","Get addresses for both networks; use mainnetAddr for production; testnetAddr for testing"
3,javascript,balance,fetch-token-balances,"Fetch all token balances for address","const response = await fetch(`https://api.hiro.so/extended/v1/address/${address}/balances`, { headers: getRandomHeader() }); const data = await response.json(); const tokenIds = Object.keys(data.fungible_tokens); tokenIds.forEach(tokenId => { const balance = Number(data.fungible_tokens[tokenId].balance); console.log(`${tokenId}: ${balance}`) })","fetch","Get all FT holdings; iterate through fungible_tokens; balance is in smallest unit"
4,javascript,balance,filter-bonding-tokens,"Filter bonding curve tokens from holdings","const tokenHoldings = []; const tokenIds = Object.keys(data.fungible_tokens); for(const tokenId of tokenIds) { const balance = Number(data.fungible_tokens[tokenId].balance); if (balance > (100 * Math.pow(10, 6)) && (tokenId.toLowerCase().includes('bonding-curve') || tokenId.toLowerCase().includes('stxcity'))) { tokenHoldings.push({ tokenId, balance }) } }","None","Filter by min balance (100 STX worth); filter by contract name pattern; useful for bot automation"
5,javascript,balance,calculate-sell-amount,"Calculate percentage of holdings to sell","const holding = 1000000; const sellPercent = 50; const amountToSell = Math.floor(holding * Number(sellPercent)/100)","None","Floor division for integer amounts; sellPercent from API request; prevents dust"
6,javascript,txOptions,basic-contract-call,"Build basic txOptions for contract call","import { makeContractCall, principalCV, uintCV, AnchorMode, PostConditionMode } from '@stacks/transactions'; const txOptions = { contractAddress: 'SP2C2YFP...', contractName: 'dex-contract', functionName: 'swap', functionArgs: [ principalCV('SP...token-contract'), uintCV(1000000) ], senderKey: account.stxPrivateKey, validateWithAbi: true, network: new StacksMainnet(), postConditions: [], anchorMode: AnchorMode.OnChainOnly, postConditionMode: PostConditionMode.Deny }","import { makeContractCall, principalCV, uintCV, AnchorMode, PostConditionMode } from '@stacks/transactions'; import { StacksMainnet } from '@stacks/network'","Complete txOptions structure; senderKey from wallet-sdk; validateWithAbi catches errors early"
7,javascript,txOptions,set-transaction-fee,"Set custom transaction fee","const txOptions = { ...baseOptions }; const txFee = 0.1; if (txFee !== null && txFee !== undefined) { txOptions.fee = Number(txFee) * Math.pow(10, 6) }","None","Fee in microSTX; 0.1 STX = 100,000 microSTX; optional parameter"
8,javascript,txOptions,random-fee-range,"Generate random fee for privacy","const randomFee = (Math.random() * (0.3 - 0.08) + 0.08).toFixed(2); txOptions.fee = Number(randomFee) * Math.pow(10, 6)","None","Random fee between 0.08-0.3 STX; prevents MEV; harder to identify bot transactions"
9,javascript,post-conditions,user-sends-ft,"Post-condition: user sends exact FT amount","import { Pc } from '@stacks/transactions'; const contractNameForPC = `${deployer}.${name}` as `${string}.${string}`; const sendFTCondition = Pc.principal(userAddress) .willSendEq(BigInt(amountToSell)).ft(contractNameForPC, symbol); postConditions.push(sendFTCondition)","import { Pc } from '@stacks/transactions'","willSendEq for exact amounts; ft() requires contract.name format; symbol is token identifier"
10,javascript,post-conditions,dex-sends-stx,"Post-condition: DEX sends minimum STX","import { Pc } from '@stacks/transactions'; const sendSTXPostCondition = Pc.principal(dexContractId) .willSendGte(100).ustx(); postConditions.push(sendSTXPostCondition)","import { Pc } from '@stacks/transactions'","willSendGte for minimum guarantee; 100 microSTX minimum; protects against zero-return exploits"
11,javascript,post-conditions,user-sends-stx,"Post-condition: user sends exact STX amount","import { Pc } from '@stacks/transactions'; const userSendSTXPC = Pc.principal(userAddress) .willSendEq(BigInt(stxAmount)).ustx(); postConditions.push(userSendSTXPC)","import { Pc } from '@stacks/transactions'","willSendEq prevents overspending; amount in microSTX; critical for buy operations"
12,javascript,post-conditions,amm-sends-ft,"Post-condition: AMM vault sends FT","import { Pc } from '@stacks/transactions'; const contractNameForPC = `${deployer}.${name}` as `${string}.${string}`; const ammSendsFTPC = Pc.principal('SP...amm-vault-v2-01') .willSendGte(BigInt(1)).ft(contractNameForPC, symbol); postConditions.push(ammSendsFTPC)","import { Pc } from '@stacks/transactions'","AMM vault holds tokens; willSendGte(1) ensures we receive something; critical for swaps"
13,javascript,broadcast,broadcast-transaction,"Broadcast transaction to network","import { makeContractCall, broadcastTransaction } from '@stacks/transactions'; const transaction = await makeContractCall(txOptions); const broadcastResponse = await broadcastTransaction(transaction, network); const txId = broadcastResponse.txid; console.log('Transaction ID:', txId)","import { makeContractCall, broadcastTransaction } from '@stacks/transactions'","makeContractCall builds tx; broadcastTransaction sends to network; txid for tracking"
14,javascript,broadcast,batch-broadcast,"Broadcast multiple transactions in parallel","const walletPromises = seedPhrasesList.map(async (seedPhrase) => { const wallet = await restoreWallet(seedPhrase); const transaction = await makeContractCall(txOptions); const response = await broadcastTransaction(transaction, network); return response.txid }); const txIds = await Promise.all(walletPromises)","None","Promise.all for parallel execution; multiple wallets for volume; collect all txIds"
15,javascript,dex,bonding-curve-sell,"Sell tokens on bonding curve DEX","const txOptions = { contractAddress: dexDeployer, contractName: dexContractName, functionName: 'sell', functionArgs: [ principalCV(tokenContractId), uintCV(amountToSell) ], senderKey: account.stxPrivateKey, validateWithAbi: true, network, postConditions: [sendSTXPostCondition, sendFTCondition], anchorMode: AnchorMode.OnChainOnly, postConditionMode: PostConditionMode.Deny }","import { principalCV, uintCV, AnchorMode, PostConditionMode } from '@stacks/transactions'","Bonding curve sell function; args: token-contract, amount; Deny mode for safety"
16,javascript,dex,alex-swap-helper,"Swap on Alex DEX using swap-helper","const txOptions = { contractAddress: 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM', contractName: 'amm-pool-v2-01', functionName: 'swap-helper', functionArgs: [ principalCV('SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM.token-wstx-v2'), principalCV('SP1E0XBN9T4B10E9QMR7XMFJPMA19D77WY3KP2QKC.token-wsbtc'), uintCV(100000000), uintCV(1000000), someCV(uintCV(1)) ], senderKey: account.stxPrivateKey, network, postConditions, anchorMode: AnchorMode.OnChainOnly, postConditionMode: PostConditionMode.Allow }","import { principalCV, uintCV, someCV, AnchorMode, PostConditionMode } from '@stacks/transactions'","Alex swap-helper pattern; args: token-x, token-y, factor, dx, min-dy; someCV for optional values"
17,javascript,dex,bitflow-swap,"Swap on Bitflow DEX","const txOptions = { contractAddress: 'SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR', contractName: 'xyk-core-v-1-2', functionName: 'swap-y-for-x', functionArgs: [ principalCV('SM1793C4R5PZ4NS4VQ4WMP7SKKYVH8JZEWSZ9HCCR.xyk-pool-sbtc-stx-v-1-1'), principalCV('SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token'), principalCV('SP1Y5YSTAHZ88XYK1VPDH24GY0HPX5J4JECTMY4A1.wstx'), uintCV(1000000), uintCV(950000) ], senderKey: account.stxPrivateKey, network, postConditions, anchorMode: AnchorMode.OnChainOnly }","import { principalCV, uintCV, AnchorMode } from '@stacks/transactions'","Bitflow XYK swap; args: pool-contract, token-y, token-x, amount-y, min-x-out"
18,javascript,quotes,fetch-bitflow-quote,"Get swap quote from Bitflow API","async function getBitflowQuote(amount: number): Promise<number> { const timestamp = Date.now(); const response = await fetch(`https://app.bitflow.finance/api/sdk/quote-for-route?tokenXId=token-stx&tokenYId=token-sbtc&amount=${amount}&timestamp=${timestamp}`); const data = await response.json(); return data.bestRoute.quote }","fetch","Fetch real-time quote; timestamp for cache busting; returns expected output amount"
19,javascript,quotes,calculate-slippage,"Calculate min receive with slippage","const quote = await getBitflowQuote(1); const minReceiveAfterSlippage = quote * 0.9; const minReceiveInDecimals = Math.floor(minReceiveAfterSlippage * Math.pow(10, 8))","None","10% slippage = 0.9 multiplier; floor to prevent decimal issues; convert to token decimals"
20,javascript,validation,validate-bonding-token,"Validate token is active bonding curve","const tokenContract = tokenId.split('::')[0]; const response = await fetch(`https://stx.city/api/searchTokens?token_contract=${tokenContract}`); const data = await response.json(); if (!data.bonding_curve || data.bonding_curve.length === 0) { console.log('Not a bonding curve token'); return false } const tokenInfo = data.bonding_curve[0]; if (tokenInfo.status !== 'active') { console.log('Token not active'); return false }","fetch","Check if token exists in bonding curve registry; validate active status; prevents trading dead tokens"
21,javascript,validation,split-contract-id,"Parse contract identifier","const dexContractId = 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.dex-v1'; const dexDeployer = dexContractId.split('.')[0]; const dexContractName = dexContractId.split('.')[1]","None","Split on dot separator; [0] is deployer address; [1] is contract name"
22,javascript,validation,extract-token-parts,"Extract token contract and symbol","const tokenId = 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.token-bonding-v1::TOKEN'; const tokenContract = tokenId.split('::')[0]; const symbol = tokenId.split('::')[1]","None","Split on :: separator; [0] is full contract id; [1] is token symbol"
23,javascript,validation,type-safe-contract-id,"TypeScript type-safe contract ID","function validateAndUseString(inputString: string): `${string}.${string}` { const parts = inputString.split('.'); return inputString as `${string}.${string}` }","None","Type assertion for Clarity contract format; prevents type errors with Pc.ft()"
24,javascript,auth,bearer-token-auth,"Protect API endpoint with bearer token","export async function POST(request: Request) { const authHeader = request.headers.get('authorization'); if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) { return new NextResponse('Unauthorized', { status: 401 }) } // Process request... }","import { NextResponse } from 'next/server'","Verify bearer token; use env vars for secrets; return 401 if invalid"
25,javascript,auth,production-auth-guard,"Only require auth in production","import { isProd } from '@/lib/dev'; if (isProd()) { const authHeader = request.headers.get('authorization'); if (authHeader !== `Bearer ${process.env.API_KEY}`) { return new NextResponse('Unauthorized', { status: 401 }) } }","None","Skip auth in development; isProd() checks NODE_ENV; easier local testing"
26,javascript,error,handle-tx-errors,"Handle transaction errors gracefully","try { const transaction = await makeContractCall(txOptions); const broadcastResponse = await broadcastTransaction(transaction, network); return NextResponse.json({ txId: broadcastResponse.txid }, { status: 201 }) } catch (error) { console.error('Error making transaction:', error); return NextResponse.json({ error: `Transaction failed: ${error}` }, { status: 500 }) }","import { NextResponse } from 'next/server'","Try-catch around tx creation; log full error; return 500 with message"
27,javascript,error,skip-failed-tokens,"Continue processing on individual failures","for(const holding of tokenHoldings) { try { const tx = await makeSellTransaction(holding); txIds.push(tx) } catch (error) { console.error(`Failed to sell ${holding.tokenId}:`, error); continue } }","None","Don't stop batch processing; log which token failed; collect successful txIds"
28,javascript,patterns,dynamic-route-config,"Force dynamic route in Next.js","export const dynamic = 'force-dynamic'","None","Disable static generation; required for API routes with env vars; prevents build caching"
29,javascript,patterns,random-api-key,"Use random API key from pool","function getRandomHeader() { const apiKeys = ['key1', 'key2', 'key3']; const randomApiKey = apiKeys[Math.floor(Math.random() * apiKeys.length)]; return { 'x-hiro-api-key': randomApiKey } }","None","Rotate API keys; avoid rate limits; distribute load across keys"
30,javascript,patterns,someCV-optional,"Use someCV for optional Clarity arguments","import { someCV, noneCV, uintCV } from '@stacks/transactions'; const minReceive = hasMinimum ? someCV(uintCV(minAmount)) : noneCV()","import { someCV, noneCV, uintCV } from '@stacks/transactions'","someCV wraps optional values; noneCV for none; matches Clarity (optional uint)"
31,javascript,wallet-sdk,multi-wallet-setup,"Set up multiple wallets from seed list","const seedPhrasesList = [seedPhrase1, seedPhrase2, seedPhrase3]; const walletPromises = seedPhrasesList.map(async (currentSeedPhrase) => { let restoredWallet = await generateWallet({ secretKey: currentSeedPhrase, password: password ?? '' }); restoredWallet = generateNewAccount(restoredWallet); return await restoreWalletAccounts({ wallet: restoredWallet, gaiaHubUrl: 'https://hub.blockstack.org', network: new StacksMainnet() }) }); const wallets = await Promise.all(walletPromises)","import { generateWallet, generateNewAccount, restoreWalletAccounts } from '@stacks/wallet-sdk'","Parallel wallet restoration; Promise.all for speed; useful for multi-wallet bots"
32,javascript,txOptions,anchor-mode-options,"Set anchor mode for transaction","import { AnchorMode } from '@stacks/transactions'; const txOptions = { ...baseOptions, anchorMode: AnchorMode.OnChainOnly }","import { AnchorMode } from '@stacks/transactions'","OnChainOnly for finality; Any for speed; OffChainOnly for microblocks"
33,javascript,txOptions,post-condition-mode,"Set post-condition mode","import { PostConditionMode } from '@stacks/transactions'; const txOptions = { ...baseOptions, postConditionMode: PostConditionMode.Deny }","import { PostConditionMode } from '@stacks/transactions'","Deny rejects unexpected transfers; Allow permits any transfer; Deny recommended for safety"
34,javascript,complete,complete-sell-bot,"Complete automated sell bot","import { generateWallet, generateNewAccount, restoreWalletAccounts, getStxAddress } from '@stacks/wallet-sdk'; import { makeContractCall, broadcastTransaction, principalCV, uintCV, Pc, AnchorMode, PostConditionMode, TransactionVersion } from '@stacks/transactions'; import { StacksMainnet } from '@stacks/network'; const wallet = await setupWallet(seedPhrase, password); const account = wallet.accounts[0]; const mainnetAddr = getStxAddress({ account: wallet.accounts[0], transactionVersion: TransactionVersion.Mainnet }); const balance = await fetchTokenBalance(mainnetAddr, tokenContract); const txOptions = { contractAddress: dexDeployer, contractName: dexContractName, functionName: 'sell', functionArgs: [principalCV(tokenContract), uintCV(balance)], senderKey: account.stxPrivateKey, network: new StacksMainnet(), postConditions: [Pc.principal(dexContract).willSendGte(100).ustx(), Pc.principal(mainnetAddr).willSendEq(BigInt(balance)).ft(tokenContract, symbol)], anchorMode: AnchorMode.OnChainOnly, postConditionMode: PostConditionMode.Deny }; const tx = await makeContractCall(txOptions); const result = await broadcastTransaction(tx, new StacksMainnet()); return result.txid","import { generateWallet, generateNewAccount, restoreWalletAccounts, getStxAddress } from '@stacks/wallet-sdk'; import { makeContractCall, broadcastTransaction, principalCV, uintCV, Pc, AnchorMode, PostConditionMode, TransactionVersion } from '@stacks/transactions'; import { StacksMainnet } from '@stacks/network'","Full sell bot pattern; restore wallet, check balance, build tx, broadcast; all safety checks included"
35,javascript,complete,complete-buy-bot,"Complete automated buy bot","import { generateWallet, generateNewAccount, restoreWalletAccounts } from '@stacks/wallet-sdk'; import { makeContractCall, broadcastTransaction, principalCV, uintCV, someCV, Pc, AnchorMode, PostConditionMode } from '@stacks/transactions'; import { StacksMainnet } from '@stacks/network'; const wallet = await setupWallet(seedPhrase, password); const account = wallet.accounts[0]; const quote = await getDexQuote(stxAmount); const minReceive = Math.floor(quote * 0.9 * Math.pow(10, tokenDecimals)); const txOptions = { contractAddress: 'SP102V8P0F7JX67ARQ77WEA3D3CFB5XW39REDT0AM', contractName: 'amm-pool-v2-01', functionName: 'swap-helper', functionArgs: [principalCV(tokenX), principalCV(tokenY), uintCV(factor), uintCV(stxAmount), someCV(uintCV(minReceive))], senderKey: account.stxPrivateKey, network: new StacksMainnet(), postConditions: [Pc.principal(userAddr).willSendEq(BigInt(stxAmount)).ustx(), Pc.principal(ammVault).willSendGte(BigInt(minReceive)).ft(tokenContract, symbol)], anchorMode: AnchorMode.OnChainOnly, postConditionMode: PostConditionMode.Allow }; const tx = await makeContractCall(txOptions); return await broadcastTransaction(tx, new StacksMainnet())","import { generateWallet, generateNewAccount, restoreWalletAccounts } from '@stacks/wallet-sdk'; import { makeContractCall, broadcastTransaction, principalCV, uintCV, someCV, Pc, AnchorMode, PostConditionMode } from '@stacks/transactions'; import { StacksMainnet } from '@stacks/network'","Full buy bot pattern; get quote, calculate slippage, build tx with post-conditions, broadcast"
36,javascript,privy,init-privy-client,"Initialize Privy server client","import { PrivyClient } from '@privy-io/server-auth'; const privyAppId = process.env.NEXT_PUBLIC_PRIVY_APP_ID; const privyAppSecret = process.env.PRIVY_APP_SECRET; const authPrivateKey = process.env.QUORUMS_PRIVATE_KEY; const privy = new PrivyClient(privyAppId, privyAppSecret, { walletApi: { authorizationPrivateKey: authPrivateKey } })","import { PrivyClient } from '@privy-io/server-auth'","Singleton pattern recommended; walletApi requires authorization private key; used for server-side wallet operations"
37,javascript,privy,verify-privy-token,"Verify Privy auth token","import { getPrivyServerClient } from '@/utils/privy-server-client'; const privy = getPrivyServerClient(); const accessToken = authHeader.replace('Bearer ', ''); try { const verifiedClaims = await privy.verifyAuthToken(accessToken); console.log('User ID:', verifiedClaims.userId) } catch { throw new Error('Invalid or expired token') }","import { getPrivyServerClient } from '@/utils/privy-server-client'","Verify JWT from frontend; extract userId from claims; throws on invalid/expired tokens"
38,javascript,privy,create-privy-wallet,"Create Privy embedded wallet","const privy = getPrivyServerClient(); const result = await privy.walletApi.createWallet({ chainType: 'bitcoin-segwit', owner: { userId }, additionalSigners: [{ signerId: process.env.NEXT_PUBLIC_QUORUMS_ID }] }); await privy.walletApi.updateWallet({ id: result.id, additionalSigners: [] })","import { getPrivyServerClient } from '@/utils/privy-server-client'","bitcoin-segwit supports Stacks; additionalSigners for quorum; remove signers after creation for full control"
39,javascript,privy,get-privy-wallet,"Get Privy wallet details","const privy = getPrivyServerClient(); const wallet = await privy.walletApi.getWallet({ id: walletId }); const publicKey = wallet.publicKey; const address = publicKeyToAddress(publicKey, 'mainnet')","import { getPrivyServerClient } from '@/utils/privy-server-client'; import { publicKeyToAddress } from '@stacks/transactions'","Fetch wallet by ID; publicKey for unsigned txs; derive Stacks address from publicKey"
40,javascript,privy,sign-raw-hash,"Sign hash with Privy wallet","import { generateAuthorizationSignature } from '@privy-io/server-auth/wallet-api'; import { v4 as uuidv4 } from 'uuid'; const idempotencyKey = uuidv4(); const input = { headers: { 'privy-app-id': process.env.NEXT_PUBLIC_PRIVY_APP_ID, 'privy-idempotency-key': idempotencyKey }, method: 'POST', url: `https://api.privy.io/v1/wallets/${walletId}/raw_sign`, version: 1, body: { params: { hash } } }; const signature = generateAuthorizationSignature({ input, authorizationPrivateKey: process.env.QUORUMS_PRIVATE_KEY }); const res = await fetch(`https://api.privy.io/v1/wallets/${walletId}/raw_sign`, { method: 'POST', headers: { ...input.headers, 'Content-Type': 'application/json', 'privy-authorization-signature': signature, Authorization: generateBasicAuthHeader(appId, appSecret) }, body: JSON.stringify(input.body) }); const signData = await res.json(); return signData.data.signature","import { generateAuthorizationSignature } from '@privy-io/server-auth/wallet-api'; import { v4 as uuidv4 } from 'uuid'","Sign pre-hashed data; idempotency key prevents duplicate signs; returns raw signature (r+s)"
41,javascript,privy,make-unsigned-contract-call,"Build unsigned contract call with Privy","import { makeUnsignedContractCall, Cl, Pc, PostConditionMode } from '@stacks/transactions'; const txOptions = { publicKey, contractAddress, contractName, functionName, functionArgs: [Cl.address(tokenContract), Cl.uint(amount)], fee: 5000, postConditionMode: PostConditionMode.Deny, postConditions: [Pc.principal(userAddr).willSendEq(amount).ustx()], network: 'mainnet' }; const transaction = await makeUnsignedContractCall(txOptions)","import { makeUnsignedContractCall, Cl, Pc, PostConditionMode } from '@stacks/transactions'","Use publicKey instead of senderKey; transaction unsigned; ready for Privy signing"
42,javascript,privy,create-sighash,"Create signature hash for Privy","import { TransactionSigner, sigHashPreSign } from '@stacks/transactions'; const transaction = await makeUnsignedContractCall(txOptions); const signer = new TransactionSigner(transaction); const preSignSigHash = sigHashPreSign(signer.sigHash, transaction.auth.authType, transaction.auth.spendingCondition.fee, transaction.auth.spendingCondition.nonce); const payload = `0x${preSignSigHash}`","import { TransactionSigner, sigHashPreSign } from '@stacks/transactions'","Generate hash before signing; includes auth type, fee, nonce; 0x prefix for Privy"
43,javascript,privy,format-signature,"Format Privy signature for Stacks","function formatStacksSignature(signature) { const hexSig = signature.startsWith('0x') ? signature.slice(2) : signature; const r = hexSig.slice(0, 64).padStart(64, '0'); const s = hexSig.slice(64, 128).padStart(64, '0'); return { r, s } }","None","Extract r and s from Privy signature; pad to 64 chars; ready for recovery ID testing"
44,javascript,privy,test-recovery-ids,"Test all recovery IDs for signature","import { createMessageSignature } from '@stacks/transactions'; const recoveryIds = ['00', '01', '02', '03']; for (const recoveryId of recoveryIds) { const testTx = await makeUnsignedContractCall(txOptions); testTx.auth.spendingCondition.signature = createMessageSignature(`${recoveryId}${r}${s}`); try { const response = await broadcastTransaction({ transaction: testTx, network: 'mainnet' }); if (!response.error) { console.log(`Success with recovery ID ${recoveryId}`); return { success: true, txid: response.txid, recoveryId } } } catch (err) { continue } }","import { createMessageSignature, broadcastTransaction } from '@stacks/transactions'","Try recovery IDs in order [01,00,02,03]; broadcast each variant; return first successful"
45,javascript,privy,broadcast-with-recovery,"Broadcast with automatic recovery ID testing","async function broadcastWithRecoveryTesting(signature, createTransactionFn, broadcastFn) { const hexSig = signature.startsWith('0x') ? signature.slice(2) : signature; const r = hexSig.slice(0, 64).padStart(64, '0'); const s = hexSig.slice(64, 128).padStart(64, '0'); const recoveryIds = ['01', '00', '02', '03']; for (const v of recoveryIds) { const formatted = `${v}${r}${s}`; const tx = await createTransactionFn(formatted); const response = await broadcastFn(tx); if (!response.error || response.reason !== 'SignatureValidation') { return { success: true, response, signatureData: { v, r, s, formatted } } } } return { success: false, response: lastError, signatureData: { v: '01', r, s, formatted: `01${r}${s}` } } }","None","Systematic recovery ID testing; tries priority order; returns working signature or best guess"
46,javascript,privy,complete-privy-buy,"Complete buy transaction with Privy","const privy = getPrivyServerClient(); const wallet = await privy.walletApi.getWallet({ id: walletId }); const publicKey = wallet.publicKey; const txOptions = { publicKey, contractAddress: dexAddress, contractName: dexName, functionName: 'buy', functionArgs: [Cl.address(dexContract), Cl.address(tokenContract), Cl.uint(BigInt(amountInMicroSTX))], fee: 5000, postConditionMode: PostConditionMode.Deny, postConditions: [Pc.principal(userAddr).willSendLte(BigInt(amountInMicroSTX)).ustx(), Pc.principal(dexContract).willSendGte(BigInt(100)).ft(tokenContract, symbol)], network: 'mainnet' }; const transaction = await makeUnsignedContractCall(txOptions); const signer = new TransactionSigner(transaction); const preSignSigHash = sigHashPreSign(signer.sigHash, transaction.auth.authType, transaction.auth.spendingCondition.fee, transaction.auth.spendingCondition.nonce); const payload = `0x${preSignSigHash}`; const rawSignData = await signRaw(walletId, payload); const signature = rawSignData.data.signature; const result = await broadcastWithRecoveryTesting(signature, async (recoveryId) => { const testTx = await makeUnsignedContractCall(txOptions); testTx.auth.spendingCondition.signature = createMessageSignature(recoveryId); return testTx }, async (tx) => await broadcastTransaction({ transaction: tx, network: 'mainnet' })); return result.response.txid","import { getPrivyServerClient } from '@/utils/privy-server-client'; import { makeUnsignedContractCall, TransactionSigner, sigHashPreSign, createMessageSignature, broadcastTransaction, Cl, Pc, PostConditionMode } from '@stacks/transactions'; import { signRaw, broadcastWithRecoveryTesting } from '@/utils'","Full Privy buy flow; makeUnsigned -> sign hash -> test recovery IDs -> broadcast; handles signature validation automatically"
47,javascript,privy,complete-privy-sell,"Complete sell transaction with Privy","const privy = getPrivyServerClient(); const wallet = await privy.walletApi.getWallet({ id: walletId }); const publicKey = wallet.publicKey; const txOptions = { publicKey, contractAddress: dexAddress, contractName: dexName, functionName: 'sell', functionArgs: [Cl.address(dexContract), Cl.address(tokenContract), Cl.uint(BigInt(tokenAmount))], fee: 5000, postConditionMode: PostConditionMode.Deny, postConditions: [Pc.principal(userAddr).willSendLte(BigInt(tokenAmount)).ft(tokenContract, symbol), Pc.principal(dexContract).willSendGte(BigInt(1)).ustx()], network: 'mainnet' }; const transaction = await makeUnsignedContractCall(txOptions); const signer = new TransactionSigner(transaction); const preSignSigHash = sigHashPreSign(signer.sigHash, transaction.auth.authType, transaction.auth.spendingCondition.fee, transaction.auth.spendingCondition.nonce); const payload = `0x${preSignSigHash}`; const rawSignData = await signRaw(walletId, payload); const signature = rawSignData.data.signature; const result = await broadcastWithRecoveryTesting(signature, async (recoveryId) => { const testTx = await makeUnsignedContractCall(txOptions); testTx.auth.spendingCondition.signature = createMessageSignature(recoveryId); return testTx }, async (tx) => await broadcastTransaction({ transaction: tx, network: 'mainnet' })); return result.response.txid","import { getPrivyServerClient } from '@/utils/privy-server-client'; import { makeUnsignedContractCall, TransactionSigner, sigHashPreSign, createMessageSignature, broadcastTransaction, Cl, Pc, PostConditionMode } from '@stacks/transactions'; import { signRaw, broadcastWithRecoveryTesting } from '@/utils'","Full Privy sell flow; willSendLte for token transfer; automatic recovery ID testing"
48,javascript,privy,privy-stx-transfer,"STX transfer with Privy wallet","const txOptions = { recipient: recipientAddress, amount: transferAmount, publicKey, network: 'mainnet', fee: 4000 }; const transaction = await makeUnsignedSTXTokenTransfer(txOptions); const signer = new TransactionSigner(transaction); const preSignSigHash = sigHashPreSign(signer.sigHash, transaction.auth.authType, transaction.auth.spendingCondition.fee, transaction.auth.spendingCondition.nonce); const payload = `0x${preSignSigHash}`; const rawSignData = await signRaw(walletId, payload); const signature = rawSignData.data.signature; const result = await broadcastWithRecoveryTesting(signature, async (recoveryId) => { const testTx = await makeUnsignedSTXTokenTransfer(txOptions); testTx.auth.spendingCondition.signature = createMessageSignature(recoveryId); return testTx }, async (tx) => await broadcastTransaction({ transaction: tx, network: 'mainnet' }))","import { makeUnsignedSTXTokenTransfer, TransactionSigner, sigHashPreSign, createMessageSignature, broadcastTransaction } from '@stacks/transactions'","Simple STX transfer; amount in microSTX; deduct fee if transferring full balance"
49,javascript,privy,batch-privy-wallets,"Process multiple Privy wallets in parallel","const results = []; for (const wallet of wallets) { try { const walletId = wallet.id; const privyWallet = await privy.walletApi.getWallet({ id: walletId }); const publicKey = privyWallet.publicKey; const tx = await executeTrade(publicKey, walletId, wallet.amount); results.push({ walletId, status: 'success', txid: tx }) } catch (error) { results.push({ walletId: wallet.id, status: 'failed', error: error.message }); continue } } return { successful: results.filter(r => r.status === 'success').length, failed: results.filter(r => r.status === 'failed').length, results }","None","Sequential processing with error handling; collect all results; continue on individual failures"
50,javascript,privy-auth,basic-auth-header,"Generate Basic Auth header for Privy API","function generateBasicAuthHeader(username, password) { const token = Buffer.from(`${username}:${password}`).toString('base64'); return `Basic ${token}` }","None","Username is appId; password is appSecret; required for all Privy API calls"
